============================= test session starts =============================
platform win32 -- Python 3.6.3, pytest-3.2.5, py-1.5.2, pluggy-0.4.0
rootdir: d:\nupic\src\python\python3, inifile:
collected 260 items

anomaly_likelihood_jeff_test.py ...ss..
anomaly_likelihood_test.py .....................
anomaly_test.py ..............
backtracking_tm_constant_test.py ..F
backtracking_tm_cpp2_test.py F
backtracking_tm_test.py FFF.sss
connections_test.py ........s
inhibition_object_test.py s
knn_classifier_test.py FFFF.FFF.sF.s
sdr_classifier_test.py ...F....................ss.
sp_learn_inference_test.py s
sp_overlap_test.py FsFs
spatial_pooler_boost_test.py FF
spatial_pooler_compatability_test.py FFFssFFFF
spatial_pooler_compute_test.py FF
spatial_pooler_cpp_api_test.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF
spatial_pooler_cpp_unit_test.py FFFF
spatial_pooler_py_api_test.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF
spatial_pooler_unit_test.py sFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFsFFFF
temporal_memory_test.py ...............................s....ss.
monitor_mixin\metric_test.py ..
monitor_mixin\trace_test.py ..

================================== FAILURES ===================================
________________________ TMConstantTest.testPyTmBasic _________________________

self = <tests.unit.nupic.algorithms.backtracking_tm_constant_test.TMConstantTest testMethod=testPyTmBasic>

    def testPyTmBasic(self):
>     self._basicTest(self.pyTm)

backtracking_tm_constant_test.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
backtracking_tm_constant_test.py:124: in _basicTest
    tm.learn(seq)
..\..\..\..\nupic\algorithms\backtracking_tm.py:2688: in learn
    enableInference=enableInference)
..\..\..\..\nupic\algorithms\backtracking_tm.py:2609: in compute
    self._updateLearningState(activeColumns)
..\..\..\..\nupic\algorithms\backtracking_tm.py:2539: in _updateLearningState
    self._learnPhase2()
..\..\..\..\nupic\algorithms\backtracking_tm.py:2407: in _learnPhase2
    c, self.lrnActiveState['t'], minThreshold = self.activationThreshold)
..\..\..\..\nupic\algorithms\backtracking_tm.py:3027: in _getBestMatchingCell
    activity = self._getSegmentActivityLevel(s, activeState)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.backtracking_tm.BacktrackingTM object at 0x000001B3963D9748>
seg = <nupic.algorithms.backtracking_tm.Segment object at 0x000001B3963D9390>
activeState = array([[1],
       [1],
       [1],
       [1],
       [1],
       [1],
       [1],
       [1],
       [1],
       [1]...      [0],
       [0],
       [0],
       [0],
       [0],
       [0],
       [0],
       [0],
       [0]], dtype=int8)
connectedSynapsesOnly = False

    def _getSegmentActivityLevel(self, seg, activeState,
                                 connectedSynapsesOnly=False):
      """
        This routine computes the activity level of a segment given activeState.
        It can tally up only connected synapses (permanence >= connectedPerm), or
        all the synapses of the segment, at either t or t-1.
    
        :param seg TODO: document
        :param activeState TODO: document
        :param connectedSynapsesOnly TODO: document
        """
      # Computing in C - *much* faster
      return getSegmentActivityLevel(seg.syns, activeState, connectedSynapsesOnly,
>                                    self.connectedPerm)
E     TypeError: getSegmentActivityLevel(): incompatible function arguments. The following argument types are supported:
E         1. (arg0: List[nupic::algorithms::Cells4::Segment], arg1: numpy.ndarray[int8], arg2: bool, arg3: float) -> int
E     
E     Invoked with: [[0, 0, 0.30000001], [2, 0, 0.30000001], [3, 0, 0.30000001], [4, 0, 0.30000001], [5, 0, 0.30000001], [7, 0, 0.30000001], [8, 0, 0.30000001]], array([[1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [1],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0],
E            [0]], dtype=int8), False, 0.5

..\..\..\..\nupic\algorithms\backtracking_tm.py:3000: TypeError
---------------------------- Captured stdout call -----------------------------
TM: learn: True
TM: active outputs(0): NONE
_______________________ BacktrackingTMCPP2Test.testTMs ________________________

self = <tests.unit.nupic.algorithms.backtracking_tm_cpp2_test.BacktrackingTMCPP2Test testMethod=testTMs>
short = True

    def testTMs(self, short=True):
      """Call basicTest2 with multiple parameter settings and ensure the C++ and
        PY versions are identical throughout."""
    
      if short == True:
        print("Testing short version")
      else:
        print("Testing long version")
    
      if short:
        print("\nTesting with fixed resource CLA - test max segment and synapses")
        tm = BacktrackingTMCPP(numberOfCols=30, cellsPerColumn=5,
                               initialPerm=.5, connectedPerm= 0.5,
                               permanenceMax=1,
                               minThreshold=8, newSynapseCount=10,
                               permanenceInc=0.1, permanenceDec=0.01,
                               globalDecay=.0, activationThreshold=8,
                               doPooling=False, segUpdateValidDuration=5,
                               seed=SEED, verbosity=VERBOSITY,
                               maxAge=0,
                               maxSegmentsPerCell=2, maxSynapsesPerSegment=10,
                               checkSynapseConsistency=True)
        tm.cells4.setCellSegmentOrder(True)
>       self.basicTest2(tm, numPatterns=15, numRepetitions=1)

backtracking_tm_cpp2_test.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
backtracking_tm_cpp2_test.py:182: in basicTest2
    self.assertTrue(fdrutils.tmDiff2(tm, tmPy, verbosity, False))
E   AssertionError: False is not true
---------------------------- Captured stdout call -----------------------------
Testing short version

Testing with fixed resource CLA - test max segment and synapses
lrnActiveState[t] diverged (array([ 0,  0,  0,  1,  3,  3,  4,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8,
        8,  8,  8,  9,  9,  9, 10, 10, 10, 10, 13, 13, 13, 14, 15, 15, 16,
       16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 20, 21, 21, 22, 23,
       23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 26, 26, 27, 28, 29,
       29], dtype=int64), array([1, 2, 3, 3, 0, 1, 0, 1, 2, 0, 3, 0, 3, 3, 4, 0, 1, 2, 3, 4, 1, 3, 4,
       0, 1, 2, 3, 0, 1, 2, 4, 3, 4, 0, 1, 2, 3, 4, 0, 1, 3, 4, 0, 1, 2, 3,
       0, 1, 2, 4, 0, 3, 4, 0, 1, 2, 3, 4, 1, 3, 4, 0, 1, 2, 3, 0, 0, 1, 2], dtype=int64))
lrnPredictedState[t] diverged (array([ 7,  7, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 18, 21,
       21, 22, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 26, 26, 29,
       29], dtype=int64), array([3, 4, 3, 4, 0, 1, 2, 3, 4, 1, 3, 4, 0, 1, 2, 3, 1, 2, 4, 3, 4, 0, 1,
       2, 3, 4, 1, 3, 4, 0, 1, 2, 3, 1, 2], dtype=int64))
__________________ BacktrackingTMTest.testCheckpointLearned ___________________

self = <tests.unit.nupic.algorithms.backtracking_tm_test.BacktrackingTMTest testMethod=testCheckpointLearned>

    def testCheckpointLearned(self):
      # Create a model and give it some inputs to learn.
      tm1 = BacktrackingTM(numberOfCols=100, cellsPerColumn=12,
                           verbosity=VERBOSITY)
      sequences = [self.generateSequence() for _ in range(5)]
      train = list(itertools.chain.from_iterable(sequences[:3]))
      for bottomUpInput in train:
        if bottomUpInput is None:
          tm1.reset()
        else:
>         tm1.compute(bottomUpInput, True, True)

backtracking_tm_test.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\backtracking_tm.py:2609: in compute
    self._updateLearningState(activeColumns)
..\..\..\..\nupic\algorithms\backtracking_tm.py:2539: in _updateLearningState
    self._learnPhase2()
..\..\..\..\nupic\algorithms\backtracking_tm.py:2407: in _learnPhase2
    c, self.lrnActiveState['t'], minThreshold = self.activationThreshold)
..\..\..\..\nupic\algorithms\backtracking_tm.py:3027: in _getBestMatchingCell
    activity = self._getSegmentActivityLevel(s, activeState)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.backtracking_tm.BacktrackingTM object at 0x000001B39648DE48>
seg = <nupic.algorithms.backtracking_tm.Segment object at 0x000001B39640A7F0>
activeState = array([[0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       ..., 
       [1, 0, 0, ..., 0, 0, 0],
       [1, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0]], dtype=int8)
connectedSynapsesOnly = False

    def _getSegmentActivityLevel(self, seg, activeState,
                                 connectedSynapsesOnly=False):
      """
        This routine computes the activity level of a segment given activeState.
        It can tally up only connected synapses (permanence >= connectedPerm), or
        all the synapses of the segment, at either t or t-1.
    
        :param seg TODO: document
        :param activeState TODO: document
        :param connectedSynapsesOnly TODO: document
        """
      # Computing in C - *much* faster
      return getSegmentActivityLevel(seg.syns, activeState, connectedSynapsesOnly,
>                                    self.connectedPerm)
E     TypeError: getSegmentActivityLevel(): incompatible function arguments. The following argument types are supported:
E         1. (arg0: List[nupic::algorithms::Cells4::Segment], arg1: numpy.ndarray[int8], arg2: bool, arg3: float) -> int
E     
E     Invoked with: [[2, 0, 0.11], [4, 0, 0.11], [7, 0, 0.11], [9, 0, 0.11], [27, 0, 0.11], [30, 0, 0.11], [31, 0, 0.11], [35, 0, 0.11], [43, 0, 0.11], [62, 0, 0.11], [65, 0, 0.11], [70, 0, 0.11], [75, 0, 0.11], [80, 0, 0.11], [90, 0, 0.11]], array([[0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0],
E            ..., 
E            [1, 0, 0, ..., 0, 0, 0],
E            [1, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0]], dtype=int8), False, 0.5

..\..\..\..\nupic\algorithms\backtracking_tm.py:3000: TypeError
______________ BacktrackingTMTest.testCheckpointMiddleOfSequence ______________

self = <tests.unit.nupic.algorithms.backtracking_tm_test.BacktrackingTMTest testMethod=testCheckpointMiddleOfSequence>

    def testCheckpointMiddleOfSequence(self):
      # Create a model and give it some inputs to learn.
      tm1 = BacktrackingTM(numberOfCols=100, cellsPerColumn=12,
                           verbosity=VERBOSITY)
      sequences = [self.generateSequence() for _ in range(5)]
      train = list(itertools.chain.from_iterable(sequences[:3] +
                                                 [sequences[3][:5]]))
      for bottomUpInput in train:
        if bottomUpInput is None:
          tm1.reset()
        else:
>         tm1.compute(bottomUpInput, True, True)

backtracking_tm_test.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\backtracking_tm.py:2609: in compute
    self._updateLearningState(activeColumns)
..\..\..\..\nupic\algorithms\backtracking_tm.py:2539: in _updateLearningState
    self._learnPhase2()
..\..\..\..\nupic\algorithms\backtracking_tm.py:2407: in _learnPhase2
    c, self.lrnActiveState['t'], minThreshold = self.activationThreshold)
..\..\..\..\nupic\algorithms\backtracking_tm.py:3027: in _getBestMatchingCell
    activity = self._getSegmentActivityLevel(s, activeState)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.backtracking_tm.BacktrackingTM object at 0x000001B3963D7518>
seg = <nupic.algorithms.backtracking_tm.Segment object at 0x000001B3963BF7F0>
activeState = array([[0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       ..., 
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0]], dtype=int8)
connectedSynapsesOnly = False

    def _getSegmentActivityLevel(self, seg, activeState,
                                 connectedSynapsesOnly=False):
      """
        This routine computes the activity level of a segment given activeState.
        It can tally up only connected synapses (permanence >= connectedPerm), or
        all the synapses of the segment, at either t or t-1.
    
        :param seg TODO: document
        :param activeState TODO: document
        :param connectedSynapsesOnly TODO: document
        """
      # Computing in C - *much* faster
      return getSegmentActivityLevel(seg.syns, activeState, connectedSynapsesOnly,
>                                    self.connectedPerm)
E     TypeError: getSegmentActivityLevel(): incompatible function arguments. The following argument types are supported:
E         1. (arg0: List[nupic::algorithms::Cells4::Segment], arg1: numpy.ndarray[int8], arg2: bool, arg3: float) -> int
E     
E     Invoked with: [[9, 0, 0.11], [10, 0, 0.11], [38, 0, 0.11], [51, 0, 0.11], [54, 0, 0.11], [56, 0, 0.11], [57, 0, 0.11], [58, 0, 0.11], [61, 0, 0.11], [62, 0, 0.11], [64, 0, 0.11], [78, 0, 0.11], [82, 0, 0.11], [84, 0, 0.11], [99, 0, 0.11]], array([[0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0],
E            ..., 
E            [0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0],
E            [0, 0, 0, ..., 0, 0, 0]], dtype=int8), False, 0.5

..\..\..\..\nupic\algorithms\backtracking_tm.py:3000: TypeError
_____________ BacktrackingTMTest.testCheckpointMiddleOfSequence2 ______________

self = <tests.unit.nupic.algorithms.backtracking_tm_test.BacktrackingTMTest testMethod=testCheckpointMiddleOfSequence2>

    def testCheckpointMiddleOfSequence2(self):
      """More complex test of checkpointing in the middle of a sequence."""
      tm1 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14,
                           False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32,
                           128, 32, 'normal')
      tm2 = BacktrackingTM(2048, 32, 0.21, 0.5, 11, 20, 0.1, 0.1, 1.0, 0.0, 14,
                           False, 5, 2, False, 1960, 0, False, 3, 10, 5, 0, 32,
                           128, 32, 'normal')
    
>     with open(resource_filename(__name__, 'data/tm_input.csv'), 'r') as fin:
E     FileNotFoundError: [Errno 2] No such file or directory: 'd:\\nupic\\src\\python\\python3\\tests\\unit\\nupic\\algorithms\\data\\tm_input.csv'

backtracking_tm_test.py:294: FileNotFoundError
____________________ KNNClassifierTest.testDistanceMetrics ____________________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testDistanceMetrics>

    def testDistanceMetrics(self):
      classifier = KNNClassifier(distanceMethod="norm", distanceNorm=2.0)
    
      dimensionality = 40
      protoA = np.array([0, 1, 3, 7, 11], dtype=np.int32)
      protoB = np.array([20, 28, 30], dtype=np.int32)
    
>     classifier.learn(protoA, 0, isSparse=dimensionality)

knn_classifier_test.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B396479F98>
inputPattern = array([ 0,  1,  3,  7, 11]), inputCategory = 0
partitionId = None, isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
____________________ KNNClassifierTest.testGetPartitionId _____________________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testGetPartitionId>

    def testGetPartitionId(self):
      """
        Test a sequence of calls to KNN to ensure we can retrieve partition Id:
            - We first learn on some patterns (including one pattern with no
              partitionId in the middle) and test that we can retrieve Ids.
            - We then invoke inference and then check partitionId again.
            - We check incorrect indices to ensure we get an exception.
            - We check the case where the partitionId to be ignored is not in
              the list.
            - We learn on one more pattern and check partitionIds again
            - We remove rows and ensure partitionIds still work
        """
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
      b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32)
      c = np.array([1, 2, 3, 14, 16, 19, 22, 24, 33], dtype=np.int32)
      d = np.array([2, 4, 8, 12, 14, 19, 22, 24, 33], dtype=np.int32)
      e = np.array([1, 3, 7, 12, 14, 19, 22, 24, 33], dtype=np.int32)
    
      denseA = np.zeros(dimensionality)
      denseA[a] = 1.0
    
>     classifier.learn(a, 0, isSparse=dimensionality, partitionId=433)

knn_classifier_test.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B3963D9A90>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = 433, isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
____________ KNNClassifierTest.testGetPartitionIdWithNoIdsAtFirst _____________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testGetPartitionIdWithNoIdsAtFirst>

    def testGetPartitionIdWithNoIdsAtFirst(self):
      """
        Tests that we can correctly retrieve partition Id even if the first few
        vectors do not have Ids
        """
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
      b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32)
      c = np.array([1, 2, 3, 14, 16, 19, 22, 24, 33], dtype=np.int32)
      d = np.array([2, 4, 8, 12, 14, 19, 22, 24, 33], dtype=np.int32)
    
      denseA = np.zeros(dimensionality)
      denseA[a] = 1.0
    
      denseD = np.zeros(dimensionality)
      denseD[d] = 1.0
    
>     classifier.learn(a, 0, isSparse=dimensionality, partitionId=None)

knn_classifier_test.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B396609A58>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = None, isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
______________________ KNNClassifierTest.testMinSparsity ______________________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testMinSparsity>

    def testMinSparsity(self):
      """Tests overlap distance with min sparsity"""
    
      # Require sparsity >= 20%
      params = {"distanceMethod": "rawOverlap", "minSparsity": 0.2}
      classifier = KNNClassifier(**params)
    
      dimensionality = 30
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
      b = np.array([2, 4, 8, 12, 14, 18, 20, 21, 28], dtype=np.int32)
    
      # This has 20% sparsity and should be inserted
      c = np.array([2, 3, 8, 11, 14, 18], dtype=np.int32)
    
      # This has 17% sparsity and should NOT be inserted
      d = np.array([2, 3, 8, 11, 18], dtype=np.int32)
    
>     numPatterns = classifier.learn(a, 0, isSparse=dimensionality)

knn_classifier_test.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B3A087F710>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = None, isSparse = 30, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
____________ KNNClassifierTest.testOverlapDistanceMethodEmptyArray ____________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testOverlapDistanceMethodEmptyArray>

    def testOverlapDistanceMethodEmptyArray(self):
      """Tests case where pattern has no ON bits"""
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([], dtype=np.int32)
    
>     numPatterns = classifier.learn(a, 0, isSparse=dimensionality)

knn_classifier_test.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B3965D1BA8>
inputPattern = array([], dtype=int32), inputCategory = 0, partitionId = None
isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
____ KNNClassifierTest.testOverlapDistanceMethodInconsistentDimensionality ____

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testOverlapDistanceMethodInconsistentDimensionality>

    def testOverlapDistanceMethodInconsistentDimensionality(self):
      """Inconsistent sparsity (input dimensionality)"""
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
    
      # Learn with incorrect dimensionality, greater than largest ON bit, but
      # inconsistent when inferring
>     numPatterns = classifier.learn(a, 0, isSparse=31)

knn_classifier_test.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B396487198>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = None, isSparse = 31, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
_____________ KNNClassifierTest.testOverlapDistanceMethodStandard _____________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testOverlapDistanceMethodStandard>

    def testOverlapDistanceMethodStandard(self):
      """Tests standard learning case for raw overlap"""
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
      b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32)
    
>     numPatterns = classifier.learn(a, 0, isSparse=dimensionality)

knn_classifier_test.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B396DDF358>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = None, isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
__________________ KNNClassifierTest.testPartitionIdExcluded __________________

self = <tests.unit.nupic.algorithms.knn_classifier_test.KNNClassifierTest testMethod=testPartitionIdExcluded>

    def testPartitionIdExcluded(self):
      """
        Tests that paritionId properly excludes training data points during
        inference
        """
      params = {"distanceMethod": "rawOverlap"}
      classifier = KNNClassifier(**params)
    
      dimensionality = 40
      a = np.array([1, 3, 7, 11, 13, 17, 19, 23, 29], dtype=np.int32)
      b = np.array([2, 4, 8, 12, 14, 18, 20, 28, 30], dtype=np.int32)
    
      denseA = np.zeros(dimensionality)
      denseA[a] = 1.0
    
      denseB = np.zeros(dimensionality)
      denseB[b] = 1.0
    
>     classifier.learn(a, 0, isSparse=dimensionality, partitionId=0)

knn_classifier_test.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.knn_classifier.KNNClassifier object at 0x000001B39648DFD0>
inputPattern = array([ 1,  3,  7, 11, 13, 17, 19, 23, 29]), inputCategory = 0
partitionId = 0, isSparse = 40, rowID = -1

    def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0,
              rowID=None):
      """
        Train the classifier to associate specified input pattern with a
        particular category.
    
        :param inputPattern: (list) The pattern to be assigned a category. If
            isSparse is 0, this should be a dense array (both ON and OFF bits
            present). Otherwise, if isSparse > 0, this should be a list of the
            indices of the non-zero bits in sorted order
    
        :param inputCategory: (int) The category to be associated to the training
            pattern
    
        :param partitionId: (int) partitionID allows you to associate an id with each
            input vector. It can be used to associate input patterns stored in the
            classifier with an external id. This can be useful for debugging or
            visualizing. Another use case is to ignore vectors with a specific id
            during inference (see description of infer() for details). There can be
            at most one partitionId per stored pattern (i.e. if two patterns are
            within distThreshold, only the first partitionId will be stored). This
            is an optional parameter.
    
        :param isSparse: (int) If 0, the input pattern is a dense representation. If
            isSparse > 0, the input pattern is a list of non-zero indices and
            isSparse is the length of the dense representation
    
        :param rowID: (int) UNKNOWN
    
        :returns: The number of patterns currently stored in the classifier
        """
      if self.verbosity >= 1:
        print("%s learn:" % g_debugPrefix)
        print("  category:", int(inputCategory))
        print("  active inputs:", _labeledInput(inputPattern,
                                                cellsPerCol=self.cellsPerCol))
    
      if isSparse > 0:
        assert all(inputPattern[i] <= inputPattern[i+1]
                   for i in range(len(inputPattern)-1)), \
                       "Sparse inputPattern must be sorted."
        assert all(bit < isSparse for bit in inputPattern), \
          ("Sparse inputPattern must not index outside the dense "
           "representation's bounds.")
    
      if rowID is None:
        rowID = self._iterationIdx
    
      # Dense vectors
      if not self.useSparseMemory:
    
        # Not supported
        assert self.cellsPerCol == 0, "not implemented for dense vectors"
    
        # If the input was given in sparse form, convert it to dense
        if isSparse > 0:
          denseInput = numpy.zeros(isSparse)
          denseInput[inputPattern] = 1.0
          inputPattern = denseInput
    
        if self._specificIndexTraining and not self._nextTrainingIndices:
          # Specific index mode without any index provided - skip training
          return self._numPatterns
    
        if self._Memory is None:
          # Initialize memory with 100 rows and numPatterns = 0
          inputWidth = len(inputPattern)
          self._Memory = numpy.zeros((100,inputWidth))
          self._numPatterns = 0
          self._M = self._Memory[:self._numPatterns]
    
        addRow = True
    
        if self._vt is not None:
          # Compute projection
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        if self.distThreshold > 0:
          # Check if input is too close to an existing input to be accepted
          dist = self._calcDistance(inputPattern)
          minDist = dist.min()
          addRow = (minDist >= self.distThreshold)
    
        if addRow:
          self._protoSizes = None     # need to re-compute
          if self._numPatterns == self._Memory.shape[0]:
            # Double the size of the memory
            self._doubleMemoryNumRows()
    
          if not self._specificIndexTraining:
            # Normal learning - append the new input vector
            self._Memory[self._numPatterns] = inputPattern
            self._numPatterns += 1
            self._categoryList.append(int(inputCategory))
          else:
            # Specific index training mode - insert vector in specified slot
            vectorIndex = self._nextTrainingIndices.pop(0)
            while vectorIndex >= self._Memory.shape[0]:
              self._doubleMemoryNumRows()
            self._Memory[vectorIndex] = inputPattern
            self._numPatterns = max(self._numPatterns, vectorIndex + 1)
            if vectorIndex >= len(self._categoryList):
              self._categoryList += [-1] * (vectorIndex -
                                            len(self._categoryList) + 1)
            self._categoryList[vectorIndex] = int(inputCategory)
    
          # Set _M to the "active" part of _Memory
          self._M = self._Memory[0:self._numPatterns]
    
          self._addPartitionId(self._numPatterns-1, partitionId)
    
      # Sparse vectors
      else:
    
        # If the input was given in sparse form, convert it to dense if necessary
        if isSparse > 0 and (self._vt is not None or self.distThreshold > 0 \
                or self.numSVDDims is not None or self.numSVDSamples is not None \
                or self.numWinners > 0):
            denseInput = numpy.zeros(isSparse)
            denseInput[inputPattern] = 1.0
            inputPattern = denseInput
            isSparse = 0
    
        # Get the input width
        if isSparse > 0:
          inputWidth = isSparse
        else:
          inputWidth = len(inputPattern)
    
        # Allocate storage if this is the first training vector
        if self._Memory is None:
          self._Memory = NearestNeighbor(0, inputWidth)
    
        # Support SVD if it is on
        if self._vt is not None:
          inputPattern = numpy.dot(self._vt, inputPattern - self._mean)
    
        # Threshold the input, zeroing out entries that are too close to 0.
        #  This is only done if we are given a dense input.
        if isSparse == 0:
          thresholdedInput = self._sparsifyVector(inputPattern, True)
        addRow = True
    
        # If given the layout of the cells, then turn on the logic that stores
        # only the start cell for bursting columns.
        if self.cellsPerCol >= 1:
          burstingCols = thresholdedInput.reshape(-1,
                                    self.cellsPerCol).min(axis=1).nonzero()[0]
          for col in burstingCols:
            thresholdedInput[(col * self.cellsPerCol) + 1 :
                             (col * self.cellsPerCol) + self.cellsPerCol] = 0
    
    
        # Don't learn entries that are too close to existing entries.
>       if self._Memory.nRows() > 0:
E       AttributeError: 'nupic.bindings.math.NearestNeighbor' object has no attribute 'nRows'

..\..\..\..\nupic\algorithms\knn_classifier.py:556: AttributeError
____________________ SDRClassifierTest.testComputeCategory ____________________

self = <tests.unit.nupic.algorithms.sdr_classifier_test.SDRClassifierTest testMethod=testComputeCategory>

    def testComputeCategory(self):
      c = self._classifier([1], 0.1, 0.1, 0)
      c.compute(recordNum=0, patternNZ=[1, 5, 9],
                classification={"bucketIdx": 4, "actValue": "D"},
                learn=True, infer=True)
      result = c.compute(recordNum=1, patternNZ=[1, 5, 9],
                         classification={"bucketIdx": 4, "actValue": "D"},
                         learn=True, infer=True)
      self.assertSetEqual(set(result.keys()), set(("actualValues", 1)))
      self.assertEqual(result["actualValues"][4], "D")
    
      predictResult = c.compute(recordNum=2, patternNZ=[1, 5, 9],
                                classification={"bucketIdx": 5,
                                                "actValue": None},
                                learn=True, infer=True)
      for value in predictResult["actualValues"]:
>       self.assertIsInstance(value, (type(None), bytes))
E       AssertionError: 'D' is not an instance of (<class 'NoneType'>, <class 'bytes'>)

sdr_classifier_test.py:249: AssertionError
________________________ TestSPFrequency.testCategory _________________________

self = <tests.unit.nupic.algorithms.sp_overlap_test.TestSPFrequency testMethod=testCategory>

    def testCategory(self):
      """Test that the most frequent possible option is chosen for a scalar
        encoded field """
>     self.frequency(n=100, w=21, seed=SEED, numColors=90, encoder = 'scalar')

sp_overlap_test.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.unit.nupic.algorithms.sp_overlap_test.TestSPFrequency testMethod=testCategory>
n = 100, w = 21, columnDimensions = 2048, numActiveColumnsPerInhArea = 40
stimulusThreshold = 0, spSeed = 1, spVerbosity = 0, numColors = 90, seed = 42
minVal = 0, maxVal = 10, encoder = 'scalar', forced = True

    def frequency(self,
                  n=15,
                  w=7,
                  columnDimensions = 2048,
                  numActiveColumnsPerInhArea = 40,
                  stimulusThreshold = 0,
                  spSeed = 1,
                  spVerbosity = 0,
                  numColors = 2,
                  seed=42,
                  minVal=0,
                  maxVal=10,
                  encoder = 'category',
                  forced=True):
    
      """ Helper function that tests whether the SP predicts the most
        frequent record """
    
      print("\nRunning SP overlap test...")
      print(encoder, 'encoder,', 'Random seed:', seed, 'and', numColors, 'colors')
      #Setting up SP and creating training patterns
    
      # Instantiate Spatial Pooler
      spImpl = SpatialPooler(
                             columnDimensions=(columnDimensions, 1),
                             inputDimensions=(1, n),
                             potentialRadius=n/2,
                             numActiveColumnsPerInhArea=numActiveColumnsPerInhArea,
                             spVerbosity=spVerbosity,
                             stimulusThreshold=stimulusThreshold,
                             potentialPct=0.5,
                             seed=spSeed,
>                            globalInhibition=True,
                             )
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=(2048, 1), inputDimensions=(1, 100), potentialRadius=50.0, numActiveColumnsPerInhArea=40, spVerbosity=0, stimulusThreshold=0, potentialPct=0.5, seed=1, globalInhibition=True

sp_overlap_test.py:116: TypeError
---------------------------- Captured stdout call -----------------------------

Running SP overlap test...
scalar encoder, Random seed: 42 and 90 colors
_________________________ TestSPFrequency.testScalar __________________________

self = <tests.unit.nupic.algorithms.sp_overlap_test.TestSPFrequency testMethod=testScalar>

    def testScalar(self):
      """Test that the most frequent possible option is chosen for a category
        encoded field """
>     self.frequency(n=30, w=21, seed=SEED, numColors=90, encoder = 'category')

sp_overlap_test.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.unit.nupic.algorithms.sp_overlap_test.TestSPFrequency testMethod=testScalar>
n = 30, w = 21, columnDimensions = 2048, numActiveColumnsPerInhArea = 40
stimulusThreshold = 0, spSeed = 1, spVerbosity = 0, numColors = 90, seed = 42
minVal = 0, maxVal = 10, encoder = 'category', forced = True

    def frequency(self,
                  n=15,
                  w=7,
                  columnDimensions = 2048,
                  numActiveColumnsPerInhArea = 40,
                  stimulusThreshold = 0,
                  spSeed = 1,
                  spVerbosity = 0,
                  numColors = 2,
                  seed=42,
                  minVal=0,
                  maxVal=10,
                  encoder = 'category',
                  forced=True):
    
      """ Helper function that tests whether the SP predicts the most
        frequent record """
    
      print("\nRunning SP overlap test...")
      print(encoder, 'encoder,', 'Random seed:', seed, 'and', numColors, 'colors')
      #Setting up SP and creating training patterns
    
      # Instantiate Spatial Pooler
      spImpl = SpatialPooler(
                             columnDimensions=(columnDimensions, 1),
                             inputDimensions=(1, n),
                             potentialRadius=n/2,
                             numActiveColumnsPerInhArea=numActiveColumnsPerInhArea,
                             spVerbosity=spVerbosity,
                             stimulusThreshold=stimulusThreshold,
                             potentialPct=0.5,
                             seed=spSeed,
>                            globalInhibition=True,
                             )
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=(2048, 1), inputDimensions=(1, 30), potentialRadius=15.0, numActiveColumnsPerInhArea=40, spVerbosity=0, stimulusThreshold=0, potentialPct=0.5, seed=1, globalInhibition=True

sp_overlap_test.py:116: TypeError
---------------------------- Captured stdout call -----------------------------

Running SP overlap test...
category encoder, Random seed: 42 and 90 colors
___________________ SpatialPoolerBoostTest.testBoostingCPP ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_boost_test.SpatialPoolerBoostTest testMethod=testBoostingCPP>

    def testBoostingCPP(self):
>     self.boostTestLoop("cpp")

spatial_pooler_boost_test.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_boost_test.py:296: in boostTestLoop
    self.boostTestPhase1()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.unit.nupic.algorithms.spatial_pooler_boost_test.SpatialPoolerBoostTest testMethod=testBoostingCPP>

    def boostTestPhase1(self):
    
      y = numpy.zeros(self.columnDimensions, dtype = uintType)
      # Do one batch through the input patterns while learning is Off
      for idx, v in enumerate(self.x):
        y.fill(0)
        self.sp.compute(v, False, y)
>       self.winningIteration[y.nonzero()[0]] = self.sp.getIterationLearnNum()
E       AttributeError: 'nupic.bindings.algorithms.SpatialPooler' object has no attribute 'getIterationLearnNum'

spatial_pooler_boost_test.py:197: AttributeError
---------------------------- Captured stdout call -----------------------------
SP seed set to: 213
{'inputDimensions': [90], 'columnDimensions': [600], 'potentialRadius': 90, 'potentialPct': 0.9, 'globalInhibition': True, 'numActiveColumnsPerInhArea': 60, 'synPermActiveInc': 0.0, 'synPermInactiveDec': 0.0, 'dutyCyclePeriod': 10, 'boostStrength': 10.0, 'seed': 213}
____________________ SpatialPoolerBoostTest.testBoostingPY ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_boost_test.SpatialPoolerBoostTest testMethod=testBoostingPY>

    def testBoostingPY(self):
>     self.boostTestLoop("py")

spatial_pooler_boost_test.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_boost_test.py:291: in boostTestLoop
    self.sp = CreateSP(imp, self.params)
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A06A4150>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
SP seed set to: 213
{'inputDimensions': [90], 'columnDimensions': [600], 'potentialRadius': 90, 'potentialPct': 0.9, 'globalInhibition': True, 'numActiveColumnsPerInhArea': 60, 'synPermActiveInc': 0.0, 'synPermInactiveDec': 0.0, 'dutyCyclePeriod': 10, 'boostStrength': 10.0, 'seed': 213}
______________ SpatialPoolerCompatibilityTest.testCompatibility1 ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testCompatibility1>

    def testCompatibility1(self):
      params = {
        "inputDimensions": [4,4],
        "columnDimensions": [5,3],
        "potentialRadius": 20,
        "potentialPct": 0.5,
        "globalInhibition": True,
        "localAreaDensity": 0,
        "numActiveColumnsPerInhArea": 5,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.001,
        "dutyCyclePeriod": 30,
        "boostStrength": 10.0,
        "seed": 4,
        "spVerbosity": 0
      }
      # This seed used to cause problems if learnMode is set to None
>     self.runSideBySide(params, seed = 63862)

spatial_pooler_compatability_test.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compatability_test.py:171: in runSideBySide
    cppSp = CreateSP("cpp", params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

imp = 'cpp'
params = {'boostStrength': 10.0, 'columnDimensions': [5, 3], 'dutyCyclePeriod': 30, 'globalInhibition': True, ...}

    def CreateSP(imp, params):
      """
      Helper class for creating an instance of the appropriate spatial pooler using
      given parameters.
    
      Parameters:
      ----------------------------
      imp:       Either 'py' or 'cpp' for creating the appropriate instance.
      params:    A dict for overriding constructor parameters. The keys must
                 correspond to contructor parameter names.
    
      Returns the SP object.
      """
      if (imp == "py"):
        spClass = PySpatialPooler
      elif (imp == "cpp"):
        spClass = CPPSpatialPooler
      else:
        raise RuntimeError("unrecognized implementation")
    
      print(params)
>     sp = spClass(**params)
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[4, 4], columnDimensions=[5, 3], potentialRadius=20, potentialPct=0.5, globalInhibition=True, localAreaDensity=0, numActiveColumnsPerInhArea=5, stimulusThreshold=0, synPermInactiveDec=0.01, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.001, dutyCyclePeriod=30, boostStrength=10.0, seed=4, spVerbosity=0

..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: TypeError
---------------------------- Captured stdout call -----------------------------
Numpy seed set to: 63862 called by testCompatibility1 line 259 -> runSideBySide
{'inputDimensions': [4, 4], 'columnDimensions': [5, 3], 'potentialRadius': 20, 'potentialPct': 0.5, 'globalInhibition': True, 'localAreaDensity': 0, 'numActiveColumnsPerInhArea': 5, 'stimulusThreshold': 0, 'synPermInactiveDec': 0.01, 'synPermActiveInc': 0.1, 'synPermConnected': 0.1, 'minPctOverlapDutyCycle': 0.001, 'dutyCyclePeriod': 30, 'boostStrength': 10.0, 'seed': 4, 'spVerbosity': 0}
______________ SpatialPoolerCompatibilityTest.testCompatibility2 ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testCompatibility2>

    def testCompatibility2(self):
      params = {
        "inputDimensions": [12,7],
        "columnDimensions": [4,15],
        "potentialRadius": 22,
        "potentialPct": 0.3,
        "globalInhibition": False,
        "localAreaDensity": 0,
        "numActiveColumnsPerInhArea": 5,
        "stimulusThreshold": 2,
        "synPermInactiveDec": 0.04,
        "synPermActiveInc": 0.14,
        "synPermConnected": 0.178,
        "minPctOverlapDutyCycle": 0.021,
        "dutyCyclePeriod": 20,
        "boostStrength": 11.0,
        "seed": 6,
        "spVerbosity": 0
      }
>     self.runSideBySide(params, convertEveryIteration=True, seed=63862)

spatial_pooler_compatability_test.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compatability_test.py:171: in runSideBySide
    cppSp = CreateSP("cpp", params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

imp = 'cpp'
params = {'boostStrength': 11.0, 'columnDimensions': [4, 15], 'dutyCyclePeriod': 20, 'globalInhibition': False, ...}

    def CreateSP(imp, params):
      """
      Helper class for creating an instance of the appropriate spatial pooler using
      given parameters.
    
      Parameters:
      ----------------------------
      imp:       Either 'py' or 'cpp' for creating the appropriate instance.
      params:    A dict for overriding constructor parameters. The keys must
                 correspond to contructor parameter names.
    
      Returns the SP object.
      """
      if (imp == "py"):
        spClass = PySpatialPooler
      elif (imp == "cpp"):
        spClass = CPPSpatialPooler
      else:
        raise RuntimeError("unrecognized implementation")
    
      print(params)
>     sp = spClass(**params)
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[12, 7], columnDimensions=[4, 15], potentialRadius=22, potentialPct=0.3, globalInhibition=False, localAreaDensity=0, numActiveColumnsPerInhArea=5, stimulusThreshold=2, synPermInactiveDec=0.04, synPermActiveInc=0.14, synPermConnected=0.178, minPctOverlapDutyCycle=0.021, dutyCyclePeriod=20, boostStrength=11.0, seed=6, spVerbosity=0

..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: TypeError
---------------------------- Captured stdout call -----------------------------
Numpy seed set to: 63862 called by testCompatibility2 line 310 -> runSideBySide
{'inputDimensions': [12, 7], 'columnDimensions': [4, 15], 'potentialRadius': 22, 'potentialPct': 0.3, 'globalInhibition': False, 'localAreaDensity': 0, 'numActiveColumnsPerInhArea': 5, 'stimulusThreshold': 2, 'synPermInactiveDec': 0.04, 'synPermActiveInc': 0.14, 'synPermConnected': 0.178, 'minPctOverlapDutyCycle': 0.021, 'dutyCyclePeriod': 20, 'boostStrength': 11.0, 'seed': 6, 'spVerbosity': 0}
______________ SpatialPoolerCompatibilityTest.testCompatibility3 ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testCompatibility3>

    def testCompatibility3(self):
      params = {
        "inputDimensions": [2,4,5],
        "columnDimensions": [4,3,3],
        "potentialRadius": 30,
        "potentialPct": 0.7,
        "globalInhibition": False,
        "localAreaDensity": 0.23,
        "numActiveColumnsPerInhArea": 0,
        "stimulusThreshold": 2,
        "synPermInactiveDec": 0.02,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.12,
        "minPctOverlapDutyCycle": 0.011,
        "dutyCyclePeriod": 25,
        "boostStrength": 11.0,
        "seed": 19,
        "spVerbosity": 0
      }
>     self.runSideBySide(params, convertEveryIteration=True, seed=63862)

spatial_pooler_compatability_test.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compatability_test.py:171: in runSideBySide
    cppSp = CreateSP("cpp", params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

imp = 'cpp'
params = {'boostStrength': 11.0, 'columnDimensions': [4, 3, 3], 'dutyCyclePeriod': 25, 'globalInhibition': False, ...}

    def CreateSP(imp, params):
      """
      Helper class for creating an instance of the appropriate spatial pooler using
      given parameters.
    
      Parameters:
      ----------------------------
      imp:       Either 'py' or 'cpp' for creating the appropriate instance.
      params:    A dict for overriding constructor parameters. The keys must
                 correspond to contructor parameter names.
    
      Returns the SP object.
      """
      if (imp == "py"):
        spClass = PySpatialPooler
      elif (imp == "cpp"):
        spClass = CPPSpatialPooler
      else:
        raise RuntimeError("unrecognized implementation")
    
      print(params)
>     sp = spClass(**params)
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[2, 4, 5], columnDimensions=[4, 3, 3], potentialRadius=30, potentialPct=0.7, globalInhibition=False, localAreaDensity=0.23, numActiveColumnsPerInhArea=0, stimulusThreshold=2, synPermInactiveDec=0.02, synPermActiveInc=0.1, synPermConnected=0.12, minPctOverlapDutyCycle=0.011, dutyCyclePeriod=25, boostStrength=11.0, seed=19, spVerbosity=0

..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: TypeError
---------------------------- Captured stdout call -----------------------------
Numpy seed set to: 63862 called by testCompatibility3 line 332 -> runSideBySide
{'inputDimensions': [2, 4, 5], 'columnDimensions': [4, 3, 3], 'potentialRadius': 30, 'potentialPct': 0.7, 'globalInhibition': False, 'localAreaDensity': 0.23, 'numActiveColumnsPerInhArea': 0, 'stimulusThreshold': 2, 'synPermInactiveDec': 0.02, 'synPermActiveInc': 0.1, 'synPermConnected': 0.12, 'minPctOverlapDutyCycle': 0.011, 'dutyCyclePeriod': 25, 'boostStrength': 11.0, 'seed': 19, 'spVerbosity': 0}
___________ SpatialPoolerCompatibilityTest.testCompatibilityNoLearn ___________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testCompatibilityNoLearn>

    def testCompatibilityNoLearn(self):
      params = {
        "inputDimensions": [4,4],
        "columnDimensions": [5,3],
        "potentialRadius": 20,
        "potentialPct": 0.5,
        "globalInhibition": True,
        "localAreaDensity": 0,
        "numActiveColumnsPerInhArea": 5,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.001,
        "dutyCyclePeriod": 30,
        "boostStrength": 10.0,
        "seed": 4,
        "spVerbosity": 0
      }
>     self.runSideBySide(params, seed = None, learnMode = False)

spatial_pooler_compatability_test.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compatability_test.py:171: in runSideBySide
    cppSp = CreateSP("cpp", params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

imp = 'cpp'
params = {'boostStrength': 10.0, 'columnDimensions': [5, 3], 'dutyCyclePeriod': 30, 'globalInhibition': True, ...}

    def CreateSP(imp, params):
      """
      Helper class for creating an instance of the appropriate spatial pooler using
      given parameters.
    
      Parameters:
      ----------------------------
      imp:       Either 'py' or 'cpp' for creating the appropriate instance.
      params:    A dict for overriding constructor parameters. The keys must
                 correspond to contructor parameter names.
    
      Returns the SP object.
      """
      if (imp == "py"):
        spClass = PySpatialPooler
      elif (imp == "cpp"):
        spClass = CPPSpatialPooler
      else:
        raise RuntimeError("unrecognized implementation")
    
      print(params)
>     sp = spClass(**params)
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[4, 4], columnDimensions=[5, 3], potentialRadius=20, potentialPct=0.5, globalInhibition=True, localAreaDensity=0, numActiveColumnsPerInhArea=5, stimulusThreshold=0, synPermInactiveDec=0.01, synPermActiveInc=0.1, synPermConnected=0.1, minPctOverlapDutyCycle=0.001, dutyCyclePeriod=30, boostStrength=10.0, seed=4, spVerbosity=0

..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: TypeError
---------------------------- Captured stdout call -----------------------------
Numpy seed set to: 266 called by testCompatibilityNoLearn line 288 -> runSideBySide
{'inputDimensions': [4, 4], 'columnDimensions': [5, 3], 'potentialRadius': 20, 'potentialPct': 0.5, 'globalInhibition': True, 'localAreaDensity': 0, 'numActiveColumnsPerInhArea': 5, 'stimulusThreshold': 0, 'synPermInactiveDec': 0.01, 'synPermActiveInc': 0.1, 'synPermConnected': 0.1, 'minPctOverlapDutyCycle': 0.001, 'dutyCyclePeriod': 30, 'boostStrength': 10.0, 'seed': 4, 'spVerbosity': 0}
___________ SpatialPoolerCompatibilityTest.testInhibitColumnsGlobal ___________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testInhibitColumnsGlobal>

    def testInhibitColumnsGlobal(self):
      params = {
        "inputDimensions": [512],
        "columnDimensions": [512],
        "globalInhibition": True,
        "numActiveColumnsPerInhArea": 40,
        "seed": 19
      }
    
>     sp1 = CreateSP("py", params)

spatial_pooler_compatability_test.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396D9B468>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
{'inputDimensions': [512], 'columnDimensions': [512], 'globalInhibition': True, 'numActiveColumnsPerInhArea': 40, 'seed': 19}
______________ SpatialPoolerCompatibilityTest.testSerialization _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testSerialization>

    def testSerialization(self):
      params = {
        'inputDimensions' : [2,4,5],
        'columnDimensions' : [4,3,3],
        'potentialRadius' : 30,
        'potentialPct' : 0.7,
        'globalInhibition' : False,
        'localAreaDensity' : 0.23,
        'numActiveColumnsPerInhArea' : 0,
        'stimulusThreshold' : 2,
        'synPermInactiveDec' : 0.02,
        'synPermActiveInc' : 0.1,
        'synPermConnected' : 0.12,
        'minPctOverlapDutyCycle' : 0.011,
        'dutyCyclePeriod' : 25,
        'boostStrength' : 11.0,
        'seed' : 19,
        'spVerbosity' : 0
      }
>     sp1 = CreateSP("py", params)

spatial_pooler_compatability_test.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:367: in __init__
    potential = self._mapPotential(columnIndex)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1403: in _mapPotential
    columnInputs = self._getInputNeighborhood(centerInput).astype(uintType)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1712: in _getInputNeighborhood
    self._inputDimensions)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

centerIndex = 0, radius = 30, dimensions = array([2, 4, 5])

    def wrappingNeighborhood(centerIndex, radius, dimensions):
      """
      Like :meth:`neighborhood`, except that the neighborhood isn't truncated when
      it's near an edge. It wraps around to the other side.
    
      :param centerIndex: (int) The index of the point. The coordinates are
             expressed as a single index by using the dimensions as a mixed radix
             definition. For example, in dimensions 42x10, the point [1, 4] is index
             1*420 + 4*10 = 460.
    
      :param radius: (int) The radius of this neighborhood about the
             ``centerIndex``.
    
      :param dimensions: (indexable sequence) The dimensions of the world outside
             this neighborhood.
    
      :returns: (numpy array) The points in the neighborhood, including
                ``centerIndex``.
      """
      centerPosition = coordinatesFromIndex(centerIndex, dimensions)
    
      intervals = []
      for i, dimension in enumerate(dimensions):
        left = centerPosition[i] - radius
        right = min(centerPosition[i] + radius,
                    left + dimensions[i] - 1)
>       interval = [v % dimension for v in range(left, right + 1)]
E       TypeError: 'numpy.float64' object cannot be interpreted as an integer

..\..\..\..\nupic\math\topology.py:148: TypeError
---------------------------- Captured stdout call -----------------------------
{'inputDimensions': [2, 4, 5], 'columnDimensions': [4, 3, 3], 'potentialRadius': 30, 'potentialPct': 0.7, 'globalInhibition': False, 'localAreaDensity': 0.23, 'numActiveColumnsPerInhArea': 0, 'stimulusThreshold': 2, 'synPermInactiveDec': 0.02, 'synPermActiveInc': 0.1, 'synPermConnected': 0.12, 'minPctOverlapDutyCycle': 0.011, 'dutyCyclePeriod': 25, 'boostStrength': 11.0, 'seed': 19, 'spVerbosity': 0}
_____________ SpatialPoolerCompatibilityTest.testSerializationRun _____________

self = <tests.unit.nupic.algorithms.spatial_pooler_compatability_test.SpatialPoolerCompatibilityTest testMethod=testSerializationRun>

    def testSerializationRun(self):
      params = {
        'inputDimensions' : [2,4,5],
        'columnDimensions' : [4,3,3],
        'potentialRadius' : 30,
        'potentialPct' : 0.7,
        'globalInhibition' : False,
        'localAreaDensity' : 0.23,
        'numActiveColumnsPerInhArea' : 0,
        'stimulusThreshold' : 2,
        'synPermInactiveDec' : 0.02,
        'synPermActiveInc' : 0.1,
        'synPermConnected' : 0.12,
        'minPctOverlapDutyCycle' : 0.011,
        'dutyCyclePeriod' : 25,
        'boostStrength' : 11.0,
        'seed' : 19,
        'spVerbosity' : 0
      }
>     self.runSerialize("py", params)

spatial_pooler_compatability_test.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compatability_test.py:215: in runSerialize
    sp1 = CreateSP(imp, params)
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:367: in __init__
    potential = self._mapPotential(columnIndex)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1403: in _mapPotential
    columnInputs = self._getInputNeighborhood(centerInput).astype(uintType)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1712: in _getInputNeighborhood
    self._inputDimensions)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

centerIndex = 0, radius = 30, dimensions = array([2, 4, 5])

    def wrappingNeighborhood(centerIndex, radius, dimensions):
      """
      Like :meth:`neighborhood`, except that the neighborhood isn't truncated when
      it's near an edge. It wraps around to the other side.
    
      :param centerIndex: (int) The index of the point. The coordinates are
             expressed as a single index by using the dimensions as a mixed radix
             definition. For example, in dimensions 42x10, the point [1, 4] is index
             1*420 + 4*10 = 460.
    
      :param radius: (int) The radius of this neighborhood about the
             ``centerIndex``.
    
      :param dimensions: (indexable sequence) The dimensions of the world outside
             this neighborhood.
    
      :returns: (numpy array) The points in the neighborhood, including
                ``centerIndex``.
      """
      centerPosition = coordinatesFromIndex(centerIndex, dimensions)
    
      intervals = []
      for i, dimension in enumerate(dimensions):
        left = centerPosition[i] - radius
        right = min(centerPosition[i] + radius,
                    left + dimensions[i] - 1)
>       interval = [v % dimension for v in range(left, right + 1)]
E       TypeError: 'numpy.float64' object cannot be interpreted as an integer

..\..\..\..\nupic\math\topology.py:148: TypeError
---------------------------- Captured stdout call -----------------------------
Numpy seed set to: 267 called by testSerializationRun line 382 -> runSerialize
{'inputDimensions': [2, 4, 5], 'columnDimensions': [4, 3, 3], 'potentialRadius': 30, 'potentialPct': 0.7, 'globalInhibition': False, 'localAreaDensity': 0.23, 'numActiveColumnsPerInhArea': 0, 'stimulusThreshold': 2, 'synPermInactiveDec': 0.02, 'synPermActiveInc': 0.1, 'synPermConnected': 0.12, 'minPctOverlapDutyCycle': 0.011, 'dutyCyclePeriod': 25, 'boostStrength': 11.0, 'seed': 19, 'spVerbosity': 0}
_________________ SpatialPoolerComputeTest.testBasicCompute1 __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_compute_test.SpatialPoolerComputeTest testMethod=testBasicCompute1>

    def testBasicCompute1(self):
      """
        Run basicComputeLoop with mostly default parameters
        """
      # Size of each input vector
      inputSize = 30
    
      # Size of each output SDR vector
      columnDimensions = 50
    
      params = {
        "inputDimensions": [inputSize],
        "columnDimensions": [columnDimensions],
        "potentialRadius": inputSize,
        'globalInhibition': True,
        "seed": int((time.time()%10000)*10),
      }
      print("testBasicCompute1, SP seed set to:",params['seed'])
>     self.basicComputeLoop('py', params, inputSize, columnDimensions)

spatial_pooler_compute_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compute_test.py:50: in basicComputeLoop
    sp = CreateSP(imp,params)
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A087ABF8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
testBasicCompute1, SP seed set to: 268
{'inputDimensions': [30], 'columnDimensions': [50], 'potentialRadius': 30, 'globalInhibition': True, 'seed': 268}
_________________ SpatialPoolerComputeTest.testBasicCompute2 __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_compute_test.SpatialPoolerComputeTest testMethod=testBasicCompute2>

    def testBasicCompute2(self):
      """
        Run basicComputeLoop with learning turned off.
        """
    
      # Size of each input vector
      inputSize = 100
    
      # Size of each output SDR vector
      columnDimensions = 100
    
      params = {
        "inputDimensions": [inputSize],
        "columnDimensions": [columnDimensions],
        "potentialRadius": inputSize,
        'globalInhibition': True,
        "synPermActiveInc": 0.0,
        "synPermInactiveDec": 0.0,
        "seed": int((time.time()%10000)*10),
      }
      print("testBasicCompute2, SP seed set to:",params['seed'])
>     self.basicComputeLoop('py', params, inputSize, columnDimensions)

spatial_pooler_compute_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
spatial_pooler_compute_test.py:50: in basicComputeLoop
    sp = CreateSP(imp,params)
..\..\..\..\nupic\support\unittesthelpers\algorithm_test_helpers.py:167: in CreateSP
    sp = spClass(**params)
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A087A990>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
testBasicCompute2, SP seed set to: 268
{'inputDimensions': [100], 'columnDimensions': [100], 'potentialRadius': 100, 'globalInhibition': True, 'synPermActiveInc': 0.0, 'synPermInactiveDec': 0.0, 'seed': 268}
_____________________ SpatialPoolerCPPAPITest.testCompute _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testCompute>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetActiveDutyCycles _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetActiveDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerCPPAPITest.testGetBoostFactors _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetBoostFactors>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerCPPAPITest.testGetBoostStrength _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetBoostStrength>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetConnectedCounts ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetConnectedCounts>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerCPPAPITest.testGetConnectedSynapses _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetConnectedSynapses>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetDutyCyclePeriod ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetDutyCyclePeriod>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetGlobalInhibition _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetGlobalInhibition>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetInhibitionRadius _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetInhibitionRadius>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerCPPAPITest.testGetIterationLearnNum _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetIterationLearnNum>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerCPPAPITest.testGetIterationNum _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetIterationNum>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetLocalAreaDensity _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetLocalAreaDensity>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_____________ SpatialPoolerCPPAPITest.testGetMinOverlapDutyCycles _____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetMinOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________ SpatialPoolerCPPAPITest.testGetMinPctOverlapDutyCycles ____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetMinPctOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________ SpatialPoolerCPPAPITest.testGetNumActiveColumnsPerInhArea __________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetNumActiveColumnsPerInhArea>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerCPPAPITest.testGetOverlapDutyCycles _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerCPPAPITest.testGetPermanence __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPermanence>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerCPPAPITest.testGetPotential ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotential>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerCPPAPITest.testGetPotentialPct _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotentialPct>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetPotentialRadius ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotentialRadius>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerCPPAPITest.testGetSpVerbosity __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSpVerbosity>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerCPPAPITest.testGetStimulusThreshold _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetStimulusThreshold>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetSynPermActiveInc _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermActiveInc>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________ SpatialPoolerCPPAPITest.testGetSynPermBelowStimulusInc ____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermBelowStimulusInc>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerCPPAPITest.testGetSynPermConnected _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermConnected>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerCPPAPITest.testGetSynPermInactiveDec ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermInactiveDec>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_____________ SpatialPoolerCPPAPITest.testGetSynPermTrimThreshold _____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermTrimThreshold>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerCPPAPITest.testGetUpdatePeriod _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetUpdatePeriod>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________________ SpatialPoolerTest.testCalculateOverlap ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_cpp_unit_test.SpatialPoolerTest testMethod=testCalculateOverlap>

    def testCalculateOverlap(self):
      sp = SpatialPooler(inputDimensions = [10],
>                        columnDimensions = [5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[10], columnDimensions=[5]

spatial_pooler_cpp_unit_test.py:44: TypeError
_________________ SpatialPoolerTest.testInhibitColumnsGlobal __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_cpp_unit_test.SpatialPoolerTest testMethod=testInhibitColumnsGlobal>

    def testInhibitColumnsGlobal(self):
      sp = SpatialPooler(inputDimensions = [10],
                         columnDimensions = [10],
                         globalInhibition = True,
                         numActiveColumnsPerInhArea = 10)
    
      overlaps = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      expectedActive = set([5, 6, 7, 8, 9])
    
>     active = sp._inhibitColumns(np.array(overlaps, dtype=realDType))
E     AttributeError: 'nupic.bindings.algorithms.SpatialPooler' object has no attribute '_inhibitColumns'

spatial_pooler_cpp_unit_test.py:89: AttributeError
___________________ SpatialPoolerTest.testUpdateDutyCycles ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_cpp_unit_test.SpatialPoolerTest testMethod=testUpdateDutyCycles>

    def testUpdateDutyCycles(self):
      sp = SpatialPooler(inputDimensions = [5],
>                        columnDimensions = [5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[5], columnDimensions=[5]

spatial_pooler_cpp_unit_test.py:153: TypeError
______________ SpatialPoolerTest.testUpdatePermanencesForColumn _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_cpp_unit_test.SpatialPoolerTest testMethod=testUpdatePermanencesForColumn>

    def testUpdatePermanencesForColumn(self):
      sp = SpatialPooler(inputDimensions = [5],
>                        columnDimensions = [5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: inputDimensions=[5], columnDimensions=[5]

spatial_pooler_cpp_unit_test.py:99: TypeError
______________________ SpatialPoolerAPITest.testCompute _______________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testCompute>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetActiveDutyCycles _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetActiveDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerAPITest.testGetBoostFactors ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetBoostFactors>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerAPITest.testGetBoostStrength __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetBoostStrength>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerAPITest.testGetConnectedCounts _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetConnectedCounts>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetConnectedSynapses ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetConnectedSynapses>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerAPITest.testGetDutyCyclePeriod _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetDutyCyclePeriod>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetGlobalInhibition _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetGlobalInhibition>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetInhibitionRadius _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetInhibitionRadius>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetIterationLearnNum ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetIterationLearnNum>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerAPITest.testGetIterationNum ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetIterationNum>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetLocalAreaDensity _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetLocalAreaDensity>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerAPITest.testGetMinOverlapDutyCycles _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetMinOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_____________ SpatialPoolerAPITest.testGetMinPctOverlapDutyCycles _____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetMinPctOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________ SpatialPoolerAPITest.testGetNumActiveColumnsPerInhArea ____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetNumActiveColumnsPerInhArea>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetOverlapDutyCycles ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetOverlapDutyCycles>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________________ SpatialPoolerAPITest.testGetPermanence ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPermanence>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
____________________ SpatialPoolerAPITest.testGetPotential ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotential>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerAPITest.testGetPotentialPct ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotentialPct>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_________________ SpatialPoolerAPITest.testGetPotentialRadius _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetPotentialRadius>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
___________________ SpatialPoolerAPITest.testGetSpVerbosity ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSpVerbosity>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetStimulusThreshold ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetStimulusThreshold>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetSynPermActiveInc _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermActiveInc>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_____________ SpatialPoolerAPITest.testGetSynPermBelowStimulusInc _____________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermBelowStimulusInc>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
________________ SpatialPoolerAPITest.testGetSynPermConnected _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermConnected>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_______________ SpatialPoolerAPITest.testGetSynPermInactiveDec ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermInactiveDec>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
______________ SpatialPoolerAPITest.testGetSynPermTrimThreshold _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetSynPermTrimThreshold>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
__________________ SpatialPoolerAPITest.testGetUpdatePeriod ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_py_api_test.SpatialPoolerAPITest testMethod=testGetUpdatePeriod>

    def setUp(self):
>     self.sp = SpatialPooler(columnDimensions=[5], inputDimensions=[5])
E     TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:
E         1. nupic.bindings.algorithms.SpatialPooler()
E         2. nupic.bindings.algorithms.SpatialPooler(inputDimensions: List[int], columnDimensions: List[int], potentialRadius: int=16, potentialPct: float=0.5, globalInhibition: bool=False, localAreaDensity: float=-1.0, numActiveColumnsPerInhArea: int=10.0, stimulusThreshold: int=0, synPermInactiveDec: float=0.01, synPermActiveInc: float=0.1, synPermConnected: float=0.1, minPctOverlapDutyCycles: float=0.001, dutyCyclePeriod: int=1000, boostStrength: float=0.0, seed: int=-1, spVerbosity: int=0, wrapAround: bool=True)
E     
E     Invoked with: kwargs: columnDimensions=[5], inputDimensions=[5]

spatial_pooler_py_api_test.py:41: TypeError
_____________________ SpatialPoolerTest.testAdaptSynapses _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testAdaptSynapses>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086EE08>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 272 called by run line 601 -> setUp
__________________ SpatialPoolerTest.testAvgColumnsPerInput ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testAvgColumnsPerInput>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A06A40F8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 273 called by run line 601 -> setUp
______________ SpatialPoolerTest.testAvgConnectedSpanForColumn1D ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testAvgConnectedSpanForColumn1D>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086E6D0>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 274 called by run line 601 -> setUp
______________ SpatialPoolerTest.testAvgConnectedSpanForColumn2D ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testAvgConnectedSpanForColumn2D>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396D9B410>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 275 called by run line 601 -> setUp
______________ SpatialPoolerTest.testAvgConnectedSpanForColumnND ______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testAvgConnectedSpanForColumnND>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086E0F8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 275 called by run line 601 -> setUp
___________________ SpatialPoolerTest.testBumpUpWeakColumns ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testBumpUpWeakColumns>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FF048>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 276 called by run line 601 -> setUp
___________________ SpatialPoolerTest.testCalculateOverlap ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testCalculateOverlap>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FF780>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 277 called by run line 601 -> setUp
_______________________ SpatialPoolerTest.testCompute1 ________________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testCompute1>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086E9E8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 278 called by run line 601 -> setUp
_______________________ SpatialPoolerTest.testCompute2 ________________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testCompute2>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FF728>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 278 called by run line 601 -> setUp
______________________ SpatialPoolerTest.testExactOutput ______________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testExactOutput>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A06A4F68>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 279 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testInhibitColumns _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testInhibitColumns>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086EBF8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 280 called by run line 601 -> setUp
_________________ SpatialPoolerTest.testInhibitColumnsGlobal __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testInhibitColumnsGlobal>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FF048>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 280 called by run line 601 -> setUp
__________________ SpatialPoolerTest.testInhibitColumnsLocal __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testInhibitColumnsLocal>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A0857468>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 281 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testInitPermanence1 ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testInitPermanence1>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A08579E8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 282 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testInitPermanence2 ____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testInitPermanence2>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FFB48>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 283 called by run line 601 -> setUp
_____________________ SpatialPoolerTest.testIsUpdateRound _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testIsUpdateRound>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A0857360>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 283 called by run line 601 -> setUp
_______________________ SpatialPoolerTest.testMapColumn _______________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testMapColumn>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A0857BA0>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 284 called by run line 601 -> setUp
_______________ SpatialPoolerTest.testMapPotential1Column1Input _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testMapPotential1Column1Input>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A086E728>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 285 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testMapPotential1D _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testMapPotential1D>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965EA518>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 286 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testMapPotential2D _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testMapPotential2D>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965EA830>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 286 called by run line 601 -> setUp
____________________ SpatialPoolerTest.testOverlapsOutput _____________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testOverlapsOutput>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3A08575C8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 287 called by run line 601 -> setUp
_______________ SpatialPoolerTest.testRaisePermanenceThreshold ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testRaisePermanenceThreshold>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965EA308>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 288 called by run line 601 -> setUp
_________________ SpatialPoolerTest.testRandomSPDoesNotLearn __________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testRandomSPDoesNotLearn>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FB048>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 288 called by run line 601 -> setUp
___________________ SpatialPoolerTest.testStripNeverLearned ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testStripNeverLearned>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FB570>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 289 called by run line 601 -> setUp
__________________ SpatialPoolerTest.testUpdateBoostFactors ___________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdateBoostFactors>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965EA830>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 290 called by run line 601 -> setUp
_________________ SpatialPoolerTest.testUpdateDutyCycleHelper _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdateDutyCycleHelper>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FB990>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 291 called by run line 601 -> setUp
________________ SpatialPoolerTest.testUpdateInhibitionRadius _________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdateInhibitionRadius>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965888E0>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 291 called by run line 601 -> setUp
________________ SpatialPoolerTest.testUpdateMinDutyCycleLocal ________________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdateMinDutyCycleLocal>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965EA9E8>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 292 called by run line 601 -> setUp
_______________ SpatialPoolerTest.testUpdateMinDutyCyclesGlobal _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdateMinDutyCyclesGlobal>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FBF10>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 293 called by run line 601 -> setUp
______________ SpatialPoolerTest.testUpdatePermanencesForColumn _______________

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testUpdatePermanencesForColumn>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396588620>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 293 called by run line 601 -> setUp
___ SpatialPoolerTest.testZeroOverlap_NoStimulusThreshold_GlobalInhibition ____

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testZeroOverlap_NoStimulusThreshold_GlobalInhibition>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396588F10>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 294 called by run line 601 -> setUp
____ SpatialPoolerTest.testZeroOverlap_NoStimulusThreshold_LocalInhibition ____

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testZeroOverlap_NoStimulusThreshold_LocalInhibition>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396588048>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 295 called by run line 601 -> setUp
____ SpatialPoolerTest.testZeroOverlap_StimulusThreshold_GlobalInhibition _____

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testZeroOverlap_StimulusThreshold_GlobalInhibition>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B3965FB518>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 296 called by run line 601 -> setUp
_____ SpatialPoolerTest.testZeroOverlap_StimulusThreshold_LocalInhibition _____

self = <tests.unit.nupic.algorithms.spatial_pooler_unit_test.SpatialPoolerTest testMethod=testZeroOverlap_StimulusThreshold_LocalInhibition>

    def setUp(self):
    
      self._params = {
        "inputDimensions": [5],
        "columnDimensions": [5],
        "potentialRadius": 5,
        "potentialPct": 0.5,
        "globalInhibition": False,
        "localAreaDensity": -1.0,
        "numActiveColumnsPerInhArea": 3,
        "stimulusThreshold": 0,
        "synPermInactiveDec": 0.01,
        "synPermActiveInc": 0.1,
        "synPermConnected": 0.10,
        "minPctOverlapDutyCycle": 0.1,
        "dutyCyclePeriod": 10,
        "boostStrength": 10.0,
        "seed": getSeed(),
        "spVerbosity": 0
      }
    
>     self._sp = SpatialPooler(**self._params)

spatial_pooler_unit_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\nupic\algorithms\spatial_pooler.py:370: in __init__
    self._updatePermanencesForColumn(perm, columnIndex, raisePerm=True)
..\..\..\..\nupic\algorithms\spatial_pooler.py:1255: in _updatePermanencesForColumn
    maskPotential = numpy.where(self._potentialPools[columnIndex] > 0)[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <nupic.algorithms.spatial_pooler.BinaryCorticalColumns object at 0x000001B396AD2308>
columnIndex = 0

    def __getitem__(self, columnIndex):
      """ Wraps getRow() such that instances may be indexed by columnIndex."""
>     return super(_SparseMatrixCorticalColumnAdapter, self).getRow(columnIndex)
E     AttributeError: 'super' object has no attribute 'getRow'

..\..\..\..\nupic\algorithms\spatial_pooler.py:64: AttributeError
---------------------------- Captured stdout call -----------------------------
New seed generated as: 296 called by run line 601 -> setUp
============= 121 failed, 118 passed, 21 skipped in 9.86 seconds ==============
*** Synapse consistency checking turned on for Cells4 ***
*** Synapse consistency checking turned on for Cells4 ***
*** Synapse consistency checking turned on for Cells4 ***
*** Synapse consistency checking turned on for Cells4 ***
*** Python segment match turned on for Cells4
